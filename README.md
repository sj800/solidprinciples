# SOLID PRINCIPLES
## WHAT | WHY | HOW ??

## What ?
Solid is acronym for a set of 5 design principles in OOPs
### Single Responsibility Principle (SRP): 
       A class should have only one reason to change, meaning it should have only one responsibility or task. 
       This principle promotes the idea that a class should focus on doing one thing well. 
       By adhering to SRP, classes become more modular and easier to understand, test, and maintain.
### Open/Closed Principle (OCP): 
        Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. 
        This principle encourages designing systems that can be easily extended with new functionalities without modifying 
        the existing codebase. This is often achieved through the use of abstraction, polymorphism, and interfaces.
### Liskov Substitution Principle (LSP): 
        Objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program.
        In other words, a subclass should be able to substitute its superclass without altering the desirable properties of the program. 
        LSP ensures that inheritance is used correctly and that subtypes adhere to the contracts established by their supertypes.
### Interface Segregation Principle (ISP): 
        Clients should not be forced to depend on interfaces they do not use. 
        This principle states that classes/interfaces should be tailored to specific 
        clients' needs instead of providing a large, monolithic interface. 
        Breaking interfaces into smaller, specific ones reduces the coupling between components and leads to more cohesive designs.
### Dependency Inversion Principle (DIP): 
        High-level modules should not depend on low-level modules; both should depend on abstractions.
        Abstractions should not depend on details; details should depend on abstractions. 
        DIP decouples modules by introducing interfaces or abstract classes between them, allowing for 
        easier changes in implementations and reducing the impact of changes on other parts of the system.

## Why ?
 Solid principles make software design more understandable, flexible and maintainable.

## How ?
 Hands-on {{youtube_link}}
